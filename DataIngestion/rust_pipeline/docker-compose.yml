services:
  rust_pipeline:
    build:
      context: . # Build context is the current directory
      dockerfile: Dockerfile
      args:
        CACHEBUST: ${CACHEBUST:-1} # Pass from env or default to 1
    volumes:
      # REMOVE mount for the config directory, it's now copied into the image
      # - ./DataIngestion/rust_pipeline:/app/config_files:ro
      # Mount the data directory from the parent folder (../Data)
      - ../../Data:/app/data:ro
      - ./pipeline_logs:/app/logs:rw
      # Mount only specific subdirectories for testing
      # - ../../Data/aarslev/celle5:/app/data/aarslev/celle5:ro
      # - ../../Data/aarslev/celle6:/app/data/aarslev/celle6:ro
      # Add depends_on if Rust pipeline needs DB/Redis ready
    depends_on:
      redis:
        condition: service_started # Redis usually starts fast, started is often enough
      db:
        condition: service_healthy # Wait for DB healthcheck to pass
    environment:
      # Pass the path to the data inside the container
      DATA_SOURCE_PATH: /app/data
      # Pass Redis URL if needed (assumes redis is running on ingestion-net)
      REDIS_URL: redis://redis:6379
      # Pass Database URL if needed (assumes db is running on ingestion-net)
      DATABASE_URL: postgresql://postgres:postgres@db:5432/postgres
      # Enable/disable null value logging (set to "true" to enable, "false" or unset to disable)
      ENABLE_NULL_LOGGING: "false"
    # deploy: # Commented out resource limits
    #   resources:
    #     limits:
    #       memory: 1G
    #       cpus: '0.5'
    networks:
      - ingestion-net

  redis:
    image: redis:alpine
    restart: always
    ports:
      - "6379:6379"
    command: redis-server --save 60 1 --loglevel warning
    volumes:
      - redis-data:/data
    networks:
      - ingestion-net
    # Add a basic healthcheck for Redis (optional but good practice)
    healthcheck:
      test: [ "CMD", "redis-cli", "ping" ]
      interval: 10s
      timeout: 5s
      retries: 5

  db:
    # Use the official TimescaleDB image with PostgreSQL 16
    image: timescale/timescaledb:latest-pg16
    restart: always
    environment:
      # Standard PostgreSQL environment variables are used
      POSTGRES_USER: "postgres"
      POSTGRES_PASSWORD: "postgres" # Use a strong password in production!
      # POSTGRES_DB: sensor_data # Optional: Define a specific database name on init
      # TIMESCALEDB_TELEMETRY: off # Optional: Disable TimescaleDB telemetry
    volumes:
      # Persist data using a named volume mapped to the standard PGDATA location
      - postgres-data:/var/lib/postgresql/data
      # Add the init script mount
      - ./db_init/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    ports:
      # Keep the standard port mapping
      - "5432:5432"
    networks:
      - ingestion-net
    # Add healthcheck for PostgreSQL/TimescaleDB
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U postgres -d postgres || exit 1" ]
      interval: 10s
      timeout: 5s
      retries: 5

  pgadmin:
    image: dpage/pgadmin4:latest
    restart: always
    environment:
      PGADMIN_DEFAULT_EMAIL: "admin@example.com" # Change this!
      PGADMIN_DEFAULT_PASSWORD: "admin" # Change this!
      PGADMIN_CONFIG_SERVER_MODE: "False" # Run in Desktop mode
      # Add these env vars to load the servers.json automatically
      PGADMIN_SETUP_EMAIL: "admin@example.com" # Must match PGADMIN_DEFAULT_EMAIL
      PGADMIN_SETUP_PASSWORD: "admin" # Must match PGADMIN_DEFAULT_PASSWORD
    volumes:
      - pgadmin-data:/var/lib/pgadmin
      # Add the servers.json mount
      - ./servers.json:/pgadmin4/servers.json:ro
    ports:
      - "5050:80" # Map host port 5050 to container port 80
    depends_on:
      db:
        # pgAdmin also depends on db being ready
        condition: service_healthy
    networks:
      - ingestion-net

volumes:
  postgres-data: # Define the named volume for PostgreSQL
  redis-data: # Define the named volume for Redis
  pgadmin-data:
    # Define the named volume for pgAdmin

networks:
  ingestion-net:
    # This file now defines and creates the network
    name: ingestion-net
    driver: bridge
